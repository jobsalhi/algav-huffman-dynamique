# Structures de données — Résumé

## Nœuds
Les nœuds de l’arbre sont représentés par une classe contenant :

- `weight`
- `symbol` (uniquement pour les feuilles)
- `left`, `right`, `parent`
- un identifiant ou index GDBH optionnel

Tous les accès à ces champs se font en **O(1)**.

---

## Arbre dynamique
L’arbre est géré par une classe `DynamicHuffmanTree` contenant :

- `root`
- `NYT` (le nœud *Not Yet Transmitted*)
- `symbol_nodes : dict[symbole → nœud]`

Caractéristiques temporelles :

- Recherche d’un symbole : **O(1)** grâce au dictionnaire
- Parcours racine ↔ feuille pour produire un code : **O(h)**

---

## Compression
L’encodeur utilise l’arbre et un **bit writer**.

Pour chaque symbole :

1. Déterminer s’il est **nouveau ou connu** → **O(1)**
2. Produire son code binaire → **O(h)**
3. Si le symbole est nouveau :
   - écrire le code du NYT
   - puis le symbole en UTF-8
4. Mettre à jour l’arbre (incrément, échanges, `finBloc`) → **O(h)**

---

## Décompression
Le décodeur utilise le même type d’arbre et un **bit reader**.

Pour chaque symbole décodé :

1. Parcours guidé par les bits jusqu’à une feuille → **O(h)**
2. Si la feuille = NYT :
   - lire le symbole brut
   - l’insérer dans l’arbre
3. Mise à jour de l’arbre → **O(h)**

---

## Pointeurs supplémentaires
Le dictionnaire `symbol_nodes` fournit un accès direct au nœud associé à chaque symbole :

- recherche immédiate en **O(1)**
- évite un parcours complet de l’arbre
- accélère fortement toutes les mises à jour de fréquences et d’échanges

---
